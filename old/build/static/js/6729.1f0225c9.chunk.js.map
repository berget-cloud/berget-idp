{"version":3,"file":"static/js/6729.1f0225c9.chunk.js","mappings":"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","sources":["../node_modules/keycloakify/src/tools/structuredCloneButFunctions.ts","../node_modules/keycloakify/src/tools/emailRegExp.ts","../node_modules/keycloakify/src/tools/formatNumber.ts","../node_modules/keycloakify/src/login/lib/useUserProfileForm.tsx","../node_modules/keycloakify/src/tools/useConstCallback.ts","login/UserProfileFormFields.tsx","../node_modules/keycloakify/src/tools/Array.prototype.every.ts"],"sourcesContent":["import \"./Object.fromEntries\";\n\n/**\n * Functionally equivalent to structuredClone but\n * functions are not cloned but kept as is.\n * (as opposed to structuredClone that chokes if it encounters a function)\n */\nexport function structuredCloneButFunctions<T>(o: T): T {\n    if (!(o instanceof Object)) {\n        return o;\n    }\n\n    if (typeof o === \"function\") {\n        return o;\n    }\n\n    if (o instanceof Array) {\n        return o.map(structuredCloneButFunctions) as any;\n    }\n\n    return Object.fromEntries(\n        Object.entries(o).map(([key, value]) => [key, structuredCloneButFunctions(value)])\n    ) as any;\n}\n","export const emailRegexp =\n    /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n","export const formatNumber = (input: string, format: string) => {\n    if (!input) {\n        return \"\";\n    }\n\n    // array holding the patterns for the number of expected digits in each part\n    const digitPattern = format.match(/{\\d+}/g);\n\n    if (!digitPattern) {\n        return \"\";\n    }\n\n    // calculate the maximum size of the given pattern based on the sum of the expected digits\n    const maxSize = digitPattern.reduce(\n        (total, p) => total + parseInt(p.replace(\"{\", \"\").replace(\"}\", \"\")),\n        0\n    );\n\n    // keep only digits\n    let rawValue = input.replace(/\\D+/g, \"\");\n\n    // make sure the value is a number\n    // @ts-expect-error: It's Keycloak's code, we trust it.\n    if (parseInt(rawValue) != rawValue) {\n        return \"\";\n    }\n\n    // make sure the number of digits does not exceed the maximum size\n    if (rawValue.length > maxSize) {\n        rawValue = rawValue.substring(0, maxSize);\n    }\n\n    // build the regex based based on the expected digits in each part\n    const formatter = digitPattern.reduce((result, p) => result + `(\\\\d${p})`, \"^\");\n\n    // if the current digits match the pattern we have each group of digits in an array\n    let digits = new RegExp(formatter).exec(rawValue);\n\n    // no match, return the raw value without any format\n    if (!digits) {\n        return input;\n    }\n\n    let result = format;\n\n    // finally format the current digits accordingly to the given format\n    for (let i = 0; i < digitPattern.length; i++) {\n        result = result.replace(digitPattern[i], digits[i + 1]);\n    }\n\n    return result;\n};\n","import \"keycloakify/tools/Array.prototype.every\";\nimport { useMemo, useReducer, useEffect, Fragment, type Dispatch } from \"react\";\nimport { assert, type Equals } from \"tsafe/assert\";\nimport { id } from \"tsafe/id\";\nimport { structuredCloneButFunctions } from \"keycloakify/tools/structuredCloneButFunctions\";\nimport { useConstCallback } from \"keycloakify/tools/useConstCallback\";\nimport { emailRegexp } from \"keycloakify/tools/emailRegExp\";\nimport { formatNumber } from \"keycloakify/tools/formatNumber\";\nimport { useInsertScriptTags } from \"keycloakify/tools/useInsertScriptTags\";\nimport type { PasswordPolicies, Attribute, Validators } from \"keycloakify/login/KcContext\";\nimport type { KcContext } from \"../KcContext\";\nimport type { MessageKey_defaultSet } from \"keycloakify/login/i18n\";\nimport { KcContextLike as KcContextLike_i18n } from \"keycloakify/login/i18n\";\nimport type { I18n } from \"../i18n\";\n\nexport type FormFieldError = {\n    errorMessage: JSX.Element;\n    errorMessageStr: string;\n    source: FormFieldError.Source;\n    fieldIndex: number | undefined;\n};\n\nexport namespace FormFieldError {\n    export type Source = Source.Validator | Source.PasswordPolicy | Source.Server | Source.Other;\n\n    export namespace Source {\n        export type Validator = {\n            type: \"validator\";\n            name: keyof Validators;\n        };\n        export type PasswordPolicy = {\n            type: \"passwordPolicy\";\n            name: keyof PasswordPolicies;\n        };\n        export type Server = {\n            type: \"server\";\n        };\n\n        export type Other = {\n            type: \"other\";\n            rule: \"passwordConfirmMatchesPassword\" | \"requiredField\";\n        };\n    }\n}\n\nexport type FormFieldState = {\n    attribute: Attribute;\n    displayableErrors: FormFieldError[];\n    valueOrValues: string | string[];\n};\n\nexport type FormState = {\n    isFormSubmittable: boolean;\n    formFieldStates: FormFieldState[];\n};\n\nexport type FormAction =\n    | {\n          action: \"update\";\n          name: string;\n          valueOrValues: string | string[];\n          /** Default false */\n          displayErrorsImmediately?: boolean;\n      }\n    | {\n          action: \"focus lost\";\n          name: string;\n          fieldIndex: number | undefined;\n      };\n\nexport type KcContextLike = KcContextLike_i18n &\n    KcContextLike_useGetErrors & {\n        profile: {\n            attributesByName: Record<string, Attribute>;\n            html5DataAnnotations?: Record<string, string>;\n        };\n        passwordRequired?: boolean;\n        realm: { registrationEmailAsUsername: boolean };\n        url: {\n            resourcesPath: string;\n        };\n    };\n\nassert<Extract<Extract<KcContext, { profile: unknown }>, { pageId: \"register.ftl\" }> extends KcContextLike ? true : false>();\n\nexport type UseUserProfileFormParams = {\n    kcContext: KcContextLike;\n    i18n: I18n;\n    doMakeUserConfirmPassword: boolean;\n};\n\nexport type ReturnTypeOfUseUserProfileForm = {\n    formState: FormState;\n    dispatchFormAction: Dispatch<FormAction>;\n};\n\nnamespace internal {\n    export type FormFieldState = {\n        attribute: Attribute;\n        errors: FormFieldError[];\n        hasLostFocusAtLeastOnce: boolean | boolean[];\n        valueOrValues: string | string[];\n    };\n\n    export type State = {\n        formFieldStates: FormFieldState[];\n    };\n}\n\nexport function useUserProfileForm(params: UseUserProfileFormParams): ReturnTypeOfUseUserProfileForm {\n    const { kcContext, i18n, doMakeUserConfirmPassword } = params;\n\n    const { insertScriptTags } = useInsertScriptTags({\n        componentOrHookName: \"useUserProfileForm\",\n        scriptTags: Object.keys(kcContext.profile?.html5DataAnnotations ?? {})\n            .filter(key => key !== \"kcMultivalued\" && key !== \"kcNumberFormat\") // NOTE: Keycloakify handles it.\n            .map(key => ({\n                type: \"module\",\n                src: `${kcContext.url.resourcesPath}/js/${key}.js`\n            }))\n    });\n\n    useEffect(() => {\n        insertScriptTags();\n    }, []);\n\n    const { getErrors } = useGetErrors({\n        kcContext,\n        i18n\n    });\n\n    const initialState = useMemo((): internal.State => {\n        // NOTE: We don't use te kcContext.profile.attributes directly because\n        // they don't includes the password and password confirm fields and we want to add them.\n        // We also want to apply some retro-compatibility and consistency patches.\n        const attributes: Attribute[] = (() => {\n            mock_user_profile_attributes_for_older_keycloak_versions: {\n                if (\n                    \"profile\" in kcContext &&\n                    \"attributesByName\" in kcContext.profile &&\n                    Object.keys(kcContext.profile.attributesByName).length !== 0\n                ) {\n                    break mock_user_profile_attributes_for_older_keycloak_versions;\n                }\n\n                if (\"register\" in kcContext && kcContext.register instanceof Object && \"formData\" in kcContext.register) {\n                    //NOTE: Handle legacy register.ftl page\n                    return ([\"firstName\", \"lastName\", \"email\", \"username\"] as const)\n                        .filter(name => (name !== \"username\" ? true : !kcContext.realm.registrationEmailAsUsername))\n                        .map(name =>\n                            id<Attribute>({\n                                name: name,\n                                displayName: id<`\\${${MessageKey_defaultSet}}`>(`\\${${name}}`),\n                                required: true,\n                                value: (kcContext.register as any).formData[name] ?? \"\",\n                                html5DataAnnotations: {},\n                                readOnly: false,\n                                validators: {},\n                                annotations: {},\n                                autocomplete: (() => {\n                                    switch (name) {\n                                        case \"email\":\n                                            return \"email\";\n                                        case \"username\":\n                                            return \"username\";\n                                        default:\n                                            return undefined;\n                                    }\n                                })()\n                            })\n                        );\n                }\n\n                if (\"user\" in kcContext && kcContext.user instanceof Object) {\n                    //NOTE: Handle legacy login-update-profile.ftl\n                    return ([\"username\", \"email\", \"firstName\", \"lastName\"] as const)\n                        .filter(name => (name !== \"username\" ? true : (kcContext.user as any).editUsernameAllowed))\n                        .map(name =>\n                            id<Attribute>({\n                                name: name,\n                                displayName: id<`\\${${MessageKey_defaultSet}}`>(`\\${${name}}`),\n                                required: true,\n                                value: (kcContext as any).user[name] ?? \"\",\n                                html5DataAnnotations: {},\n                                readOnly: false,\n                                validators: {},\n                                annotations: {},\n                                autocomplete: (() => {\n                                    switch (name) {\n                                        case \"email\":\n                                            return \"email\";\n                                        case \"username\":\n                                            return \"username\";\n                                        default:\n                                            return undefined;\n                                    }\n                                })()\n                            })\n                        );\n                }\n\n                if (\"email\" in kcContext && kcContext.email instanceof Object) {\n                    //NOTE: Handle legacy update-email.ftl\n                    return [\n                        id<Attribute>({\n                            name: \"email\",\n                            displayName: id<`\\${${MessageKey_defaultSet}}`>(`\\${email}`),\n                            required: true,\n                            value: (kcContext.email as any).value ?? \"\",\n                            html5DataAnnotations: {},\n                            readOnly: false,\n                            validators: {},\n                            annotations: {},\n                            autocomplete: \"email\"\n                        })\n                    ];\n                }\n\n                assert(false, \"Unable to mock user profile from the current kcContext\");\n            }\n\n            return Object.values(kcContext.profile.attributesByName).map(structuredCloneButFunctions);\n        })();\n\n        // Retro-compatibility and consistency patches\n        attributes.forEach(attribute => {\n            patch_legacy_group: {\n                if (typeof attribute.group !== \"string\") {\n                    break patch_legacy_group;\n                }\n\n                const { group, groupDisplayHeader, groupDisplayDescription, groupAnnotations } = attribute as Attribute & {\n                    group: string;\n                    groupDisplayHeader?: string;\n                    groupDisplayDescription?: string;\n                    groupAnnotations: Record<string, string>;\n                };\n\n                delete attribute.group;\n                // @ts-expect-error\n                delete attribute.groupDisplayHeader;\n                // @ts-expect-error\n                delete attribute.groupDisplayDescription;\n                // @ts-expect-error\n                delete attribute.groupAnnotations;\n\n                if (group === \"\") {\n                    break patch_legacy_group;\n                }\n\n                attribute.group = {\n                    name: group,\n                    displayHeader: groupDisplayHeader,\n                    displayDescription: groupDisplayDescription,\n                    annotations: groupAnnotations,\n                    html5DataAnnotations: {}\n                };\n            }\n\n            // Attributes with options rendered by default as select inputs\n            if (attribute.validators.options !== undefined && attribute.annotations.inputType === undefined) {\n                attribute.annotations.inputType = \"select\";\n            }\n\n            // Consistency patch on values/value property\n            {\n                if (getIsMultivaluedSingleField({ attribute })) {\n                    attribute.multivalued = true;\n                }\n\n                if (attribute.multivalued) {\n                    attribute.values ??= attribute.value !== undefined ? [attribute.value] : [];\n                    delete attribute.value;\n                } else {\n                    attribute.value ??= attribute.values?.[0];\n                    delete attribute.values;\n                }\n            }\n        });\n\n        add_password_and_password_confirm: {\n            if (!kcContext.passwordRequired) {\n                break add_password_and_password_confirm;\n            }\n\n            attributes.forEach((attribute, i) => {\n                if (attribute.name !== (kcContext.realm.registrationEmailAsUsername ? \"email\" : \"username\")) {\n                    // NOTE: We want to add password and password-confirm after the field that identifies the user.\n                    // It's either email or username.\n                    return;\n                }\n\n                attributes.splice(\n                    i + 1,\n                    0,\n                    {\n                        name: \"password\",\n                        displayName: id<`\\${${MessageKey_defaultSet}}`>(\"${password}\"),\n                        required: true,\n                        readOnly: false,\n                        validators: {},\n                        annotations: {},\n                        autocomplete: \"new-password\",\n                        html5DataAnnotations: {}\n                    },\n                    {\n                        name: \"password-confirm\",\n                        displayName: id<`\\${${MessageKey_defaultSet}}`>(\"${passwordConfirm}\"),\n                        required: true,\n                        readOnly: false,\n                        validators: {},\n                        annotations: {},\n                        html5DataAnnotations: {},\n                        autocomplete: \"new-password\"\n                    }\n                );\n            });\n        }\n\n        const initialFormFieldState: {\n            attribute: Attribute;\n            valueOrValues: string | string[];\n        }[] = [];\n\n        for (const attribute of attributes) {\n            handle_multi_valued_attribute: {\n                if (!attribute.multivalued) {\n                    break handle_multi_valued_attribute;\n                }\n\n                const values = attribute.values?.length ? attribute.values : [\"\"];\n\n                apply_validator_min_range: {\n                    if (getIsMultivaluedSingleField({ attribute })) {\n                        break apply_validator_min_range;\n                    }\n\n                    const validator = attribute.validators.multivalued;\n\n                    if (validator === undefined) {\n                        break apply_validator_min_range;\n                    }\n\n                    const { min: minStr } = validator;\n\n                    if (!minStr) {\n                        break apply_validator_min_range;\n                    }\n\n                    const min = parseInt(`${minStr}`);\n\n                    for (let index = values.length; index < min; index++) {\n                        values.push(\"\");\n                    }\n                }\n\n                initialFormFieldState.push({\n                    attribute,\n                    valueOrValues: values\n                });\n\n                continue;\n            }\n\n            initialFormFieldState.push({\n                attribute,\n                valueOrValues: attribute.value ?? \"\"\n            });\n        }\n\n        const initialState: internal.State = {\n            formFieldStates: initialFormFieldState.map(({ attribute, valueOrValues }) => ({\n                attribute,\n                errors: getErrors({\n                    attributeName: attribute.name,\n                    formFieldStates: initialFormFieldState\n                }),\n                hasLostFocusAtLeastOnce:\n                    valueOrValues instanceof Array && !getIsMultivaluedSingleField({ attribute }) ? valueOrValues.map(() => false) : false,\n                valueOrValues: valueOrValues\n            }))\n        };\n\n        return initialState;\n    }, []);\n\n    const [state, dispatchFormAction] = useReducer(function reducer(state: internal.State, formAction: FormAction): internal.State {\n        const formFieldState = state.formFieldStates.find(({ attribute }) => attribute.name === formAction.name);\n\n        assert(formFieldState !== undefined);\n\n        (() => {\n            switch (formAction.action) {\n                case \"update\":\n                    formFieldState.valueOrValues = formAction.valueOrValues;\n\n                    apply_formatters: {\n                        const { attribute } = formFieldState;\n\n                        const { kcNumberFormat } = attribute.html5DataAnnotations ?? {};\n\n                        if (!kcNumberFormat) {\n                            break apply_formatters;\n                        }\n\n                        if (formFieldState.valueOrValues instanceof Array) {\n                            formFieldState.valueOrValues = formFieldState.valueOrValues.map(value => formatNumber(value, kcNumberFormat));\n                        } else {\n                            formFieldState.valueOrValues = formatNumber(formFieldState.valueOrValues, kcNumberFormat);\n                        }\n                    }\n\n                    formFieldState.errors = getErrors({\n                        attributeName: formAction.name,\n                        formFieldStates: state.formFieldStates\n                    });\n\n                    simulate_focus_lost: {\n                        const { displayErrorsImmediately = false } = formAction;\n\n                        if (!displayErrorsImmediately) {\n                            break simulate_focus_lost;\n                        }\n\n                        for (const fieldIndex of formAction.valueOrValues instanceof Array\n                            ? formAction.valueOrValues.map((...[, index]) => index)\n                            : [undefined]) {\n                            state = reducer(state, {\n                                action: \"focus lost\",\n                                name: formAction.name,\n                                fieldIndex\n                            });\n                        }\n                    }\n\n                    update_password_confirm: {\n                        if (doMakeUserConfirmPassword) {\n                            break update_password_confirm;\n                        }\n\n                        if (formAction.name !== \"password\") {\n                            break update_password_confirm;\n                        }\n\n                        state = reducer(state, {\n                            action: \"update\",\n                            name: \"password-confirm\",\n                            valueOrValues: formAction.valueOrValues,\n                            displayErrorsImmediately: formAction.displayErrorsImmediately\n                        });\n                    }\n\n                    trigger_password_confirm_validation_on_password_change: {\n                        if (!doMakeUserConfirmPassword) {\n                            break trigger_password_confirm_validation_on_password_change;\n                        }\n\n                        if (formAction.name !== \"password\") {\n                            break trigger_password_confirm_validation_on_password_change;\n                        }\n\n                        state = reducer(state, {\n                            action: \"update\",\n                            name: \"password-confirm\",\n                            valueOrValues: (() => {\n                                const formFieldState = state.formFieldStates.find(({ attribute }) => attribute.name === \"password-confirm\");\n\n                                assert(formFieldState !== undefined);\n\n                                return formFieldState.valueOrValues;\n                            })(),\n                            displayErrorsImmediately: formAction.displayErrorsImmediately\n                        });\n                    }\n\n                    return;\n                case \"focus lost\":\n                    if (formFieldState.hasLostFocusAtLeastOnce instanceof Array) {\n                        const { fieldIndex } = formAction;\n                        assert(fieldIndex !== undefined);\n                        formFieldState.hasLostFocusAtLeastOnce[fieldIndex] = true;\n                        return;\n                    }\n\n                    formFieldState.hasLostFocusAtLeastOnce = true;\n                    return;\n            }\n            assert<Equals<typeof formAction, never>>(false);\n        })();\n\n        return { ...state };\n    }, initialState);\n\n    const formState: FormState = useMemo(\n        () => ({\n            formFieldStates: state.formFieldStates.map(\n                ({ errors, hasLostFocusAtLeastOnce: hasLostFocusAtLeastOnceOrArr, attribute, ...valueOrValuesWrap }) => ({\n                    displayableErrors: errors.filter(error => {\n                        const hasLostFocusAtLeastOnce =\n                            typeof hasLostFocusAtLeastOnceOrArr === \"boolean\"\n                                ? hasLostFocusAtLeastOnceOrArr\n                                : error.fieldIndex !== undefined\n                                  ? hasLostFocusAtLeastOnceOrArr[error.fieldIndex]\n                                  : hasLostFocusAtLeastOnceOrArr[hasLostFocusAtLeastOnceOrArr.length - 1];\n\n                        switch (error.source.type) {\n                            case \"server\":\n                                return true;\n                            case \"other\":\n                                switch (error.source.rule) {\n                                    case \"requiredField\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"passwordConfirmMatchesPassword\":\n                                        return hasLostFocusAtLeastOnce;\n                                }\n                                assert<Equals<typeof error.source.rule, never>>(false);\n                            case \"passwordPolicy\":\n                                switch (error.source.name) {\n                                    case \"length\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"digits\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"lowerCase\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"upperCase\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"specialChars\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"notUsername\":\n                                        return true;\n                                    case \"notEmail\":\n                                        return true;\n                                }\n                                assert<Equals<typeof error.source, never>>(false);\n                            case \"validator\":\n                                switch (error.source.name) {\n                                    case \"length\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"pattern\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"email\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"integer\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"multivalued\":\n                                        return hasLostFocusAtLeastOnce;\n                                    case \"options\":\n                                        return hasLostFocusAtLeastOnce;\n                                }\n                                assert<Equals<typeof error.source, never>>(false);\n                        }\n                    }),\n                    attribute,\n                    ...valueOrValuesWrap\n                })\n            ),\n            isFormSubmittable: state.formFieldStates.every(({ errors }) => errors.length === 0)\n        }),\n        [state]\n    );\n\n    return {\n        formState,\n        dispatchFormAction\n    };\n}\n\ntype KcContextLike_useGetErrors = KcContextLike_i18n & {\n    messagesPerField: Pick<KcContext[\"messagesPerField\"], \"existsError\" | \"get\">;\n    passwordPolicies?: PasswordPolicies;\n};\n\nassert<KcContextLike extends KcContextLike_useGetErrors ? true : false>();\n\nfunction useGetErrors(params: { kcContext: KcContextLike_useGetErrors; i18n: I18n }) {\n    const { kcContext, i18n } = params;\n\n    const { messagesPerField, passwordPolicies } = kcContext;\n\n    const { msg, msgStr, advancedMsg, advancedMsgStr } = i18n;\n\n    const getErrors = useConstCallback(\n        (params: {\n            attributeName: string;\n            formFieldStates: {\n                attribute: Attribute;\n                valueOrValues: string | string[];\n            }[];\n        }): FormFieldError[] => {\n            const { attributeName, formFieldStates } = params;\n\n            const formFieldState = formFieldStates.find(({ attribute }) => attribute.name === attributeName);\n\n            assert(formFieldState !== undefined);\n\n            const { attribute } = formFieldState;\n\n            const valueOrValues = (() => {\n                let { valueOrValues } = formFieldState;\n\n                unFormat_number: {\n                    const { kcNumberUnFormat } = attribute.html5DataAnnotations ?? {};\n\n                    if (!kcNumberUnFormat) {\n                        break unFormat_number;\n                    }\n\n                    if (valueOrValues instanceof Array) {\n                        valueOrValues = valueOrValues.map(value => formatNumber(value, kcNumberUnFormat));\n                    } else {\n                        valueOrValues = formatNumber(valueOrValues, kcNumberUnFormat);\n                    }\n                }\n\n                return valueOrValues;\n            })();\n\n            assert(attribute !== undefined);\n\n            server_side_error: {\n                if (attribute.multivalued) {\n                    const defaultValues = attribute.values?.length ? attribute.values : [\"\"];\n\n                    assert(valueOrValues instanceof Array);\n\n                    const values = valueOrValues;\n\n                    if (JSON.stringify(defaultValues) !== JSON.stringify(values.slice(0, defaultValues.length))) {\n                        break server_side_error;\n                    }\n                } else {\n                    const defaultValue = attribute.value ?? \"\";\n\n                    assert(typeof valueOrValues === \"string\");\n\n                    const value = valueOrValues;\n\n                    if (defaultValue !== value) {\n                        break server_side_error;\n                    }\n                }\n\n                let doesErrorExist: boolean;\n\n                try {\n                    doesErrorExist = messagesPerField.existsError(attributeName);\n                } catch {\n                    break server_side_error;\n                }\n\n                if (!doesErrorExist) {\n                    break server_side_error;\n                }\n\n                const errorMessageStr = messagesPerField.get(attributeName);\n\n                return [\n                    {\n                        errorMessageStr,\n                        errorMessage: (\n                            <span\n                                key={0}\n                                dangerouslySetInnerHTML={{\n                                    __html: errorMessageStr\n                                }}\n                            />\n                        ),\n                        fieldIndex: undefined,\n                        source: {\n                            type: \"server\"\n                        }\n                    }\n                ];\n            }\n\n            handle_multi_valued_multi_fields: {\n                if (!attribute.multivalued) {\n                    break handle_multi_valued_multi_fields;\n                }\n\n                if (getIsMultivaluedSingleField({ attribute })) {\n                    break handle_multi_valued_multi_fields;\n                }\n\n                assert(valueOrValues instanceof Array);\n\n                const values = valueOrValues;\n\n                const errors = values\n                    .map((...[, index]) => {\n                        const specificValueErrors = getErrors({\n                            attributeName,\n                            formFieldStates: formFieldStates.map(formFieldState => {\n                                if (formFieldState.attribute.name === attributeName) {\n                                    assert(formFieldState.valueOrValues instanceof Array);\n                                    return {\n                                        attribute: {\n                                            ...attribute,\n                                            annotations: {\n                                                ...attribute.annotations,\n                                                inputType: undefined\n                                            },\n                                            multivalued: false\n                                        },\n                                        valueOrValues: formFieldState.valueOrValues[index]\n                                    };\n                                }\n\n                                return formFieldState;\n                            })\n                        });\n\n                        return specificValueErrors\n                            .filter(error => {\n                                if (error.source.type === \"other\" && error.source.rule === \"requiredField\") {\n                                    return false;\n                                }\n\n                                return true;\n                            })\n                            .map(\n                                (error): FormFieldError => ({\n                                    ...error,\n                                    fieldIndex: index\n                                })\n                            );\n                    })\n                    .reduce((acc, errors) => [...acc, ...errors], []);\n\n                required_field: {\n                    if (!attribute.required) {\n                        break required_field;\n                    }\n\n                    if (values.every(value => value !== \"\")) {\n                        break required_field;\n                    }\n\n                    const msgArgs = [\"error-user-attribute-required\"] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source: {\n                            type: \"other\",\n                            rule: \"requiredField\"\n                        }\n                    });\n                }\n\n                return errors;\n            }\n\n            handle_multi_valued_single_field: {\n                if (!attribute.multivalued) {\n                    break handle_multi_valued_single_field;\n                }\n\n                if (!getIsMultivaluedSingleField({ attribute })) {\n                    break handle_multi_valued_single_field;\n                }\n\n                const validatorName = \"multivalued\";\n\n                const validator = attribute.validators[validatorName];\n\n                if (validator === undefined) {\n                    return [];\n                }\n\n                const { min: minStr } = validator;\n\n                const min = minStr ? parseInt(`${minStr}`) : attribute.required ? 1 : 0;\n\n                assert(!isNaN(min));\n\n                const { max: maxStr } = validator;\n\n                const max = !maxStr ? Infinity : parseInt(`${maxStr}`);\n\n                assert(!isNaN(max));\n\n                assert(valueOrValues instanceof Array);\n\n                const values = valueOrValues;\n\n                if (min <= values.length && values.length <= max) {\n                    return [];\n                }\n\n                const msgArgs = [\"error-invalid-multivalued-size\", `${min}`, `${max}`] as const;\n\n                return [\n                    {\n                        errorMessage: <Fragment key={0}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source: {\n                            type: \"validator\",\n                            name: validatorName\n                        }\n                    }\n                ];\n            }\n\n            assert(typeof valueOrValues === \"string\");\n\n            const value = valueOrValues;\n\n            const errors: FormFieldError[] = [];\n\n            check_password_policies: {\n                if (attributeName !== \"password\") {\n                    break check_password_policies;\n                }\n\n                if (passwordPolicies === undefined) {\n                    break check_password_policies;\n                }\n\n                check_password_policy_x: {\n                    const policyName = \"length\";\n\n                    const policy = passwordPolicies[policyName];\n\n                    if (!policy) {\n                        break check_password_policy_x;\n                    }\n\n                    const minLength = policy;\n\n                    if (value.length >= minLength) {\n                        break check_password_policy_x;\n                    }\n\n                    const msgArgs = [\"invalidPasswordMinLengthMessage\", `${minLength}`] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source: {\n                            type: \"passwordPolicy\",\n                            name: policyName\n                        }\n                    });\n                }\n\n                check_password_policy_x: {\n                    const policyName = \"digits\";\n\n                    const policy = passwordPolicies[policyName];\n\n                    if (!policy) {\n                        break check_password_policy_x;\n                    }\n\n                    const minNumberOfDigits = policy;\n\n                    if (value.split(\"\").filter(char => !isNaN(parseInt(char))).length >= minNumberOfDigits) {\n                        break check_password_policy_x;\n                    }\n\n                    const msgArgs = [\"invalidPasswordMinDigitsMessage\", `${minNumberOfDigits}`] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source: {\n                            type: \"passwordPolicy\",\n                            name: policyName\n                        }\n                    });\n                }\n\n                check_password_policy_x: {\n                    const policyName = \"lowerCase\";\n\n                    const policy = passwordPolicies[policyName];\n\n                    if (!policy) {\n                        break check_password_policy_x;\n                    }\n\n                    const minNumberOfLowerCaseChar = policy;\n\n                    if (\n                        value.split(\"\").filter(char => char === char.toLowerCase() && char !== char.toUpperCase()).length >= minNumberOfLowerCaseChar\n                    ) {\n                        break check_password_policy_x;\n                    }\n\n                    const msgArgs = [\"invalidPasswordMinLowerCaseCharsMessage\", `${minNumberOfLowerCaseChar}`] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source: {\n                            type: \"passwordPolicy\",\n                            name: policyName\n                        }\n                    });\n                }\n\n                check_password_policy_x: {\n                    const policyName = \"upperCase\";\n\n                    const policy = passwordPolicies[policyName];\n\n                    if (!policy) {\n                        break check_password_policy_x;\n                    }\n\n                    const minNumberOfUpperCaseChar = policy;\n\n                    if (\n                        value.split(\"\").filter(char => char === char.toUpperCase() && char !== char.toLowerCase()).length >= minNumberOfUpperCaseChar\n                    ) {\n                        break check_password_policy_x;\n                    }\n\n                    const msgArgs = [\"invalidPasswordMinUpperCaseCharsMessage\", `${minNumberOfUpperCaseChar}`] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source: {\n                            type: \"passwordPolicy\",\n                            name: policyName\n                        }\n                    });\n                }\n\n                check_password_policy_x: {\n                    const policyName = \"specialChars\";\n\n                    const policy = passwordPolicies[policyName];\n\n                    if (!policy) {\n                        break check_password_policy_x;\n                    }\n\n                    const minNumberOfSpecialChar = policy;\n\n                    if (value.split(\"\").filter(char => !char.match(/[a-zA-Z0-9]/)).length >= minNumberOfSpecialChar) {\n                        break check_password_policy_x;\n                    }\n\n                    const msgArgs = [\"invalidPasswordMinSpecialCharsMessage\", `${minNumberOfSpecialChar}`] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source: {\n                            type: \"passwordPolicy\",\n                            name: policyName\n                        }\n                    });\n                }\n\n                check_password_policy_x: {\n                    const policyName = \"notUsername\";\n\n                    const notUsername = passwordPolicies[policyName];\n\n                    if (!notUsername) {\n                        break check_password_policy_x;\n                    }\n\n                    const usernameFormFieldState = formFieldStates.find(formFieldState => formFieldState.attribute.name === \"username\");\n\n                    if (!usernameFormFieldState) {\n                        break check_password_policy_x;\n                    }\n\n                    const usernameValue = (() => {\n                        let { valueOrValues } = usernameFormFieldState;\n\n                        assert(typeof valueOrValues === \"string\");\n\n                        unFormat_number: {\n                            const { kcNumberUnFormat } = attribute.html5DataAnnotations ?? {};\n\n                            if (!kcNumberUnFormat) {\n                                break unFormat_number;\n                            }\n\n                            valueOrValues = formatNumber(valueOrValues, kcNumberUnFormat);\n                        }\n\n                        return valueOrValues;\n                    })();\n\n                    if (usernameValue === \"\") {\n                        break check_password_policy_x;\n                    }\n\n                    if (value !== usernameValue) {\n                        break check_password_policy_x;\n                    }\n\n                    const msgArgs = [\"invalidPasswordNotUsernameMessage\"] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source: {\n                            type: \"passwordPolicy\",\n                            name: policyName\n                        }\n                    });\n                }\n\n                check_password_policy_x: {\n                    const policyName = \"notEmail\";\n\n                    const notEmail = passwordPolicies[policyName];\n\n                    if (!notEmail) {\n                        break check_password_policy_x;\n                    }\n\n                    const emailFormFieldState = formFieldStates.find(formFieldState => formFieldState.attribute.name === \"email\");\n\n                    if (!emailFormFieldState) {\n                        break check_password_policy_x;\n                    }\n\n                    assert(typeof emailFormFieldState.valueOrValues === \"string\");\n\n                    {\n                        const emailValue = emailFormFieldState.valueOrValues;\n\n                        if (emailValue === \"\") {\n                            break check_password_policy_x;\n                        }\n\n                        if (value !== emailValue) {\n                            break check_password_policy_x;\n                        }\n                    }\n\n                    const msgArgs = [\"invalidPasswordNotEmailMessage\"] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source: {\n                            type: \"passwordPolicy\",\n                            name: policyName\n                        }\n                    });\n                }\n            }\n\n            password_confirm_matches_password: {\n                if (attributeName !== \"password-confirm\") {\n                    break password_confirm_matches_password;\n                }\n\n                const passwordFormFieldState = formFieldStates.find(formFieldState => formFieldState.attribute.name === \"password\");\n\n                assert(passwordFormFieldState !== undefined);\n\n                assert(typeof passwordFormFieldState.valueOrValues === \"string\");\n\n                {\n                    const passwordValue = passwordFormFieldState.valueOrValues;\n\n                    if (value === passwordValue) {\n                        break password_confirm_matches_password;\n                    }\n                }\n\n                const msgArgs = [\"invalidPasswordConfirmMessage\"] as const;\n\n                errors.push({\n                    errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                    errorMessageStr: msgStr(...msgArgs),\n                    fieldIndex: undefined,\n                    source: {\n                        type: \"other\",\n                        rule: \"passwordConfirmMatchesPassword\"\n                    }\n                });\n            }\n\n            const { validators } = attribute;\n\n            required_field: {\n                if (!attribute.required) {\n                    break required_field;\n                }\n\n                if (value !== \"\") {\n                    break required_field;\n                }\n\n                const msgArgs = [\"error-user-attribute-required\"] as const;\n\n                errors.push({\n                    errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                    errorMessageStr: msgStr(...msgArgs),\n                    fieldIndex: undefined,\n                    source: {\n                        type: \"other\",\n                        rule: \"requiredField\"\n                    }\n                });\n            }\n\n            validator_x: {\n                const validatorName = \"length\";\n\n                const validator = validators[validatorName];\n\n                if (!validator) {\n                    break validator_x;\n                }\n\n                const { \"ignore.empty.value\": ignoreEmptyValue = false, max, min } = validator;\n\n                if (ignoreEmptyValue && value === \"\") {\n                    break validator_x;\n                }\n\n                const source: FormFieldError.Source = {\n                    type: \"validator\",\n                    name: validatorName\n                };\n\n                if (max && value.length > parseInt(`${max}`)) {\n                    const msgArgs = [\"error-invalid-length-too-long\", `${max}`] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source\n                    });\n                }\n\n                if (min && value.length < parseInt(`${min}`)) {\n                    const msgArgs = [\"error-invalid-length-too-short\", `${min}`] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source\n                    });\n                }\n            }\n\n            validator_x: {\n                const validatorName = \"pattern\";\n\n                const validator = validators[validatorName];\n\n                if (validator === undefined) {\n                    break validator_x;\n                }\n\n                const { \"ignore.empty.value\": ignoreEmptyValue = false, pattern, \"error-message\": errorMessageKey } = validator;\n\n                if (ignoreEmptyValue && value === \"\") {\n                    break validator_x;\n                }\n\n                if (new RegExp(pattern).test(value)) {\n                    break validator_x;\n                }\n\n                const msgArgs = [errorMessageKey ?? id<MessageKey_defaultSet>(\"shouldMatchPattern\"), pattern] as const;\n\n                errors.push({\n                    errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{advancedMsg(...msgArgs)}</Fragment>,\n                    errorMessageStr: advancedMsgStr(...msgArgs),\n                    fieldIndex: undefined,\n                    source: {\n                        type: \"validator\",\n                        name: validatorName\n                    }\n                });\n            }\n\n            validator_x: {\n                {\n                    const lastError = errors[errors.length - 1];\n                    if (lastError !== undefined && lastError.source.type === \"validator\" && lastError.source.name === \"pattern\") {\n                        break validator_x;\n                    }\n                }\n\n                const validatorName = \"email\";\n\n                const validator = validators[validatorName];\n\n                if (validator === undefined) {\n                    break validator_x;\n                }\n\n                const { \"ignore.empty.value\": ignoreEmptyValue = false } = validator;\n\n                if (ignoreEmptyValue && value === \"\") {\n                    break validator_x;\n                }\n\n                if (emailRegexp.test(value)) {\n                    break validator_x;\n                }\n\n                const msgArgs = [id<MessageKey_defaultSet>(\"invalidEmailMessage\")] as const;\n\n                errors.push({\n                    errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                    errorMessageStr: msgStr(...msgArgs),\n                    fieldIndex: undefined,\n                    source: {\n                        type: \"validator\",\n                        name: validatorName\n                    }\n                });\n            }\n\n            validator_x: {\n                const validatorName = \"integer\";\n\n                const validator = validators[validatorName];\n\n                if (validator === undefined) {\n                    break validator_x;\n                }\n\n                const { \"ignore.empty.value\": ignoreEmptyValue = false, max, min } = validator;\n\n                if (ignoreEmptyValue && value === \"\") {\n                    break validator_x;\n                }\n\n                const intValue = parseInt(value);\n\n                const source: FormFieldError.Source = {\n                    type: \"validator\",\n                    name: validatorName\n                };\n\n                if (isNaN(intValue)) {\n                    const msgArgs = [\"mustBeAnInteger\"] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source\n                    });\n\n                    break validator_x;\n                }\n\n                if (max && intValue > parseInt(`${max}`)) {\n                    const msgArgs = [\"error-number-out-of-range-too-big\", `${max}`] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source\n                    });\n\n                    break validator_x;\n                }\n\n                if (min && intValue < parseInt(`${min}`)) {\n                    const msgArgs = [\"error-number-out-of-range-too-small\", `${min}`] as const;\n\n                    errors.push({\n                        errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                        errorMessageStr: msgStr(...msgArgs),\n                        fieldIndex: undefined,\n                        source\n                    });\n\n                    break validator_x;\n                }\n            }\n\n            validator_x: {\n                const validatorName = \"options\";\n\n                const validator = validators[validatorName];\n\n                if (validator === undefined) {\n                    break validator_x;\n                }\n\n                if (value === \"\") {\n                    break validator_x;\n                }\n\n                if (validator.options.indexOf(value) >= 0) {\n                    break validator_x;\n                }\n\n                const msgArgs = [id<MessageKey_defaultSet>(\"notAValidOption\")] as const;\n\n                errors.push({\n                    errorMessage: <Fragment key={`${attributeName}-${errors.length}`}>{msg(...msgArgs)}</Fragment>,\n                    errorMessageStr: msgStr(...msgArgs),\n                    fieldIndex: undefined,\n                    source: {\n                        type: \"validator\",\n                        name: validatorName\n                    }\n                });\n            }\n\n            //TODO: Implement missing validators. See Validators type definition.\n\n            return errors;\n        }\n    );\n\n    return { getErrors };\n}\n\nfunction getIsMultivaluedSingleField(params: { attribute: Attribute }) {\n    const { attribute } = params;\n\n    return attribute.annotations.inputType?.startsWith(\"multiselect\") ?? false;\n}\n\nexport function getButtonToDisplayForMultivaluedAttributeField(params: { attribute: Attribute; values: string[]; fieldIndex: number }) {\n    const { attribute, values, fieldIndex } = params;\n\n    const hasRemove = (() => {\n        if (values.length === 1) {\n            return false;\n        }\n\n        const minCount = (() => {\n            const { multivalued } = attribute.validators;\n\n            if (multivalued === undefined) {\n                return undefined;\n            }\n\n            const minStr = multivalued.min;\n\n            if (minStr === undefined) {\n                return undefined;\n            }\n\n            return parseInt(`${minStr}`);\n        })();\n\n        if (minCount === undefined) {\n            return true;\n        }\n\n        if (values.length === minCount) {\n            return false;\n        }\n\n        return true;\n    })();\n\n    const hasAdd = (() => {\n        if (fieldIndex + 1 !== values.length) {\n            return false;\n        }\n\n        const maxCount = (() => {\n            const { multivalued } = attribute.validators;\n\n            if (multivalued === undefined) {\n                return undefined;\n            }\n\n            const maxStr = multivalued.max;\n\n            if (maxStr === undefined) {\n                return undefined;\n            }\n\n            return parseInt(`${maxStr}`);\n        })();\n\n        if (maxCount === undefined) {\n            return true;\n        }\n\n        return values.length !== maxCount;\n    })();\n\n    return { hasRemove, hasAdd };\n}\n","import { useRef, useState } from \"react\";\nimport { Parameters } from \"tsafe/Parameters\";\n\n/** https://stackoverflow.com/questions/65890278/why-cant-usecallback-always-return-the-same-ref */\nexport function useConstCallback<\n    T extends ((...args: any[]) => unknown) | undefined | null\n>(callback: NonNullable<T>): T {\n    const callbackRef = useRef<typeof callback>(null as any);\n\n    callbackRef.current = callback;\n\n    return useState(\n        () =>\n            (...args: Parameters<T>) =>\n                callbackRef.current(...args)\n    )[0] as T;\n}\n","import { useEffect, useReducer, Fragment } from \"react\";\nimport { assert } from \"keycloakify/tools/assert\";\nimport type { KcClsx } from \"keycloakify/login/lib/kcClsx\";\nimport {\n    useUserProfileForm,\n    getButtonToDisplayForMultivaluedAttributeField,\n    type FormAction,\n    type FormFieldError\n} from \"keycloakify/login/lib/useUserProfileForm\";\nimport type { UserProfileFormFieldsProps } from \"keycloakify/login/UserProfileFormFieldsProps\";\nimport type { Attribute } from \"keycloakify/login/KcContext\";\nimport type { KcContext } from \"./KcContext\";\nimport type { I18n } from \"./i18n\";\nimport { Input } from \"../components/ui/input\";\nimport { PasswordWrapper } from \"../components/ui/PasswordWrapper\";\n\n/**\n * Renders each form field by looping through formFieldStates:\n *\n * formFieldStates.map(({ attribute, displayableErrors, valueOrValues }) => {\n *   ├─ GroupLabel (optional): Displays the group header if the field belongs to a group.\n *   ├─ BeforeField (optional): Custom component rendered before the form field.\n *   ├─ Form Field\n *   │   ├─ Label: Displays the field's name (e.g., \"Username\", \"Email\").\n *   │   ├─ Input Field (dynamic based on field type):\n *   │   │   ├─ InputTag: Standard input fields like text, email, etc.\n *   │   │   ├─ TextareaTag: For textarea fields.\n *   │   │   ├─ SelectTag: For dropdown/select fields.\n *   │   │   ├─ InputTagSelects: For radio buttons or checkboxes.\n *   │   │   └─ PasswordWrapper: For password fields with show/hide functionality.\n *   │   └─ Helper Text (optional): Additional information displayed before or after the input field.\n *   ├─ FieldErrors (optional): Displays validation errors for the current field.\n *   ├─ AddRemoveButtonsMultiValuedAttribute (optional): Add/Remove buttons for multiple values in the field.\n *   └─ AfterField (optional): Custom component rendered after the form field.\n * })\n */\n\nexport default function UserProfileFormFields(props: UserProfileFormFieldsProps<KcContext, I18n>) {\n    const { kcContext, i18n, kcClsx, onIsFormSubmittableValueChange, doMakeUserConfirmPassword, BeforeField, AfterField } = props;\n\n    const { advancedMsg } = i18n;\n\n    const {\n        formState: { formFieldStates, isFormSubmittable },\n        dispatchFormAction\n    } = useUserProfileForm({\n        kcContext,\n        i18n,\n        doMakeUserConfirmPassword\n    });\n\n    useEffect(() => {\n        onIsFormSubmittableValueChange(isFormSubmittable);\n    }, [isFormSubmittable]);\n\n    const groupNameRef = { current: \"\" };\n\n    return (\n        <div className=\"prose dark:prose-invert \">\n            {formFieldStates.map(({ attribute, displayableErrors, valueOrValues }) => {\n                return (\n                    <div className=\" my-5\">\n                        <Fragment key={attribute.name}>\n                            <GroupLabel attribute={attribute} groupNameRef={groupNameRef} i18n={i18n} kcClsx={kcClsx} />\n                            {BeforeField !== undefined && (\n                                <BeforeField\n                                    attribute={attribute}\n                                    dispatchFormAction={dispatchFormAction}\n                                    displayableErrors={displayableErrors}\n                                    valueOrValues={valueOrValues}\n                                    kcClsx={kcClsx}\n                                    i18n={i18n}\n                                />\n                            )}\n                            <div\n                                // className={kcClsx(\"kcFormGroupClass\")}\n                                className=\"\"\n                                style={{\n                                    display: attribute.name === \"password-confirm\" && !doMakeUserConfirmPassword ? \"none\" : undefined\n                                }}\n                            >\n                                <div className=\"mx-6\">\n                                    <label htmlFor={attribute.name} className=\"\">\n                                        {advancedMsg(attribute.displayName ?? \"\")}\n                                    </label>\n                                    {attribute.required && <span className=\"text-danger\"> *</span>}\n                                </div>\n                                <div className={kcClsx(\"kcInputWrapperClass\")}>\n                                    {attribute.annotations.inputHelperTextBefore !== undefined && (\n                                        <div\n                                            className={kcClsx(\"kcInputHelperTextBeforeClass\")}\n                                            id={`form-help-text-before-${attribute.name}`}\n                                            aria-live=\"polite\"\n                                        >\n                                            {advancedMsg(attribute.annotations.inputHelperTextBefore)}\n                                        </div>\n                                    )}\n                                    <InputFieldByType\n                                        attribute={attribute}\n                                        valueOrValues={valueOrValues}\n                                        displayableErrors={displayableErrors}\n                                        dispatchFormAction={dispatchFormAction}\n                                        kcClsx={kcClsx}\n                                        i18n={i18n}\n                                    />\n                                    <FieldErrors attribute={attribute} displayableErrors={displayableErrors} kcClsx={kcClsx} fieldIndex={undefined} />\n                                    {attribute.annotations.inputHelperTextAfter !== undefined && (\n                                        <div\n                                            className={kcClsx(\"kcInputHelperTextAfterClass\")}\n                                            id={`form-help-text-after-${attribute.name}`}\n                                            aria-live=\"polite\"\n                                        >\n                                            {advancedMsg(attribute.annotations.inputHelperTextAfter)}\n                                        </div>\n                                    )}\n\n                                    {AfterField !== undefined && (\n                                        <AfterField\n                                            attribute={attribute}\n                                            dispatchFormAction={dispatchFormAction}\n                                            displayableErrors={displayableErrors}\n                                            valueOrValues={valueOrValues}\n                                            kcClsx={kcClsx}\n                                            i18n={i18n}\n                                        />\n                                    )}\n                                    {/* NOTE: Downloading of html5DataAnnotations scripts is done in the useUserProfileForm hook */}\n                                </div>\n                            </div>\n                        </Fragment>\n                    </div>\n                );\n            })}\n        </div>\n    );\n}\n/**\n * GroupLabel:\n * This component is responsible for rendering a label and description for form field groups.\n * It checks whether the current form field belongs to a group and, if so, renders the group's header and description.\n * The group name is compared with a reference (`groupNameRef`) to ensure that the label is only rendered once per group.\n * It uses `i18n` for internationalization, translating the group's header and description.\n *\n * Props:\n * - attribute: The current form field's attribute object, which contains details about the field's group, name, and more.\n * - groupNameRef: A reference object that tracks the current group name to prevent duplicate labels for the same group.\n * - i18n: An internationalization object used to translate messages.\n * - kcClsx: A utility function used to apply Keycloak-specific CSS classes.\n */\nfunction GroupLabel(props: {\n    attribute: Attribute;\n    groupNameRef: {\n        current: string;\n    };\n    i18n: I18n;\n    kcClsx: KcClsx;\n}) {\n    const { attribute, groupNameRef, i18n, kcClsx } = props;\n\n    const { advancedMsg } = i18n;\n\n    if (attribute.group?.name !== groupNameRef.current) {\n        groupNameRef.current = attribute.group?.name ?? \"\";\n\n        if (groupNameRef.current !== \"\") {\n            assert(attribute.group !== undefined);\n\n            return (\n                <div\n                    className={kcClsx(\"kcFormGroupClass\")}\n                    {...Object.fromEntries(Object.entries(attribute.group.html5DataAnnotations).map(([key, value]) => [`data-${key}`, value]))}\n                >\n                    {(() => {\n                        const groupDisplayHeader = attribute.group.displayHeader ?? \"\";\n                        const groupHeaderText = groupDisplayHeader !== \"\" ? advancedMsg(groupDisplayHeader) : attribute.group.name;\n\n                        return (\n                            <div className={kcClsx(\"kcContentWrapperClass\")}>\n                                <label id={`header-${attribute.group.name}`} className={kcClsx(\"kcFormGroupHeader\")}>\n                                    {groupHeaderText}\n                                </label>\n                            </div>\n                        );\n                    })()}\n                    {(() => {\n                        const groupDisplayDescription = attribute.group.displayDescription ?? \"\";\n\n                        if (groupDisplayDescription !== \"\") {\n                            const groupDescriptionText = advancedMsg(groupDisplayDescription);\n\n                            return (\n                                <div className={kcClsx(\"kcLabelWrapperClass\")}>\n                                    <label id={`description-${attribute.group.name}`} className={kcClsx(\"kcLabelClass\")}>\n                                        {groupDescriptionText}\n                                    </label>\n                                </div>\n                            );\n                        }\n\n                        return null;\n                    })()}\n                </div>\n            );\n        }\n    }\n\n    return null;\n}\n\nfunction FieldErrors(props: { attribute: Attribute; displayableErrors: FormFieldError[]; fieldIndex: number | undefined; kcClsx: KcClsx }) {\n    const { attribute, fieldIndex, kcClsx } = props;\n\n    const displayableErrors = props.displayableErrors.filter(error => error.fieldIndex === fieldIndex);\n\n    if (displayableErrors.length === 0) {\n        return null;\n    }\n\n    return (\n        <span\n            id={`input-error-${attribute.name}${fieldIndex === undefined ? \"\" : `-${fieldIndex}`}`}\n            // className={kcClsx(\"kcInputErrorMessageClass\")}\n            className=\"text-danger text-md \"\n            aria-live=\"polite\"\n        >\n            {displayableErrors\n                .filter(error => error.fieldIndex === fieldIndex)\n                .map(({ errorMessage }, i, arr) => (\n                    <Fragment key={i}>\n                        {errorMessage}\n                        {arr.length - 1 !== i && <br />}\n                    </Fragment>\n                ))}\n        </span>\n    );\n}\n\ntype InputFieldByTypeProps = {\n    attribute: Attribute;\n    valueOrValues: string | string[];\n    displayableErrors: FormFieldError[];\n    dispatchFormAction: React.Dispatch<FormAction>;\n    i18n: I18n;\n    kcClsx: KcClsx;\n};\n\nfunction InputFieldByType(props: InputFieldByTypeProps) {\n    const { attribute, valueOrValues } = props;\n\n    switch (attribute.annotations.inputType) {\n        case \"textarea\":\n            return <TextareaTag {...props} />;\n        case \"select\":\n        case \"multiselect\":\n            return <SelectTag {...props} />;\n        case \"select-radiobuttons\":\n        case \"multiselect-checkboxes\":\n            return <InputTagSelects {...props} />;\n        default: {\n            if (valueOrValues instanceof Array) {\n                return (\n                    <>\n                        {valueOrValues.map((...[, i]) => (\n                            <InputTag key={i} {...props} fieldIndex={i} />\n                        ))}\n                    </>\n                );\n            }\n\n            const inputNode = <InputTag {...props} fieldIndex={undefined} />;\n\n            if (attribute.name === \"password\" || attribute.name === \"password-confirm\") {\n                return (\n                    <PasswordWrapper kcClsx={props.kcClsx} i18n={props.i18n} passwordInputId={attribute.name}>\n                        {inputNode}\n                    </PasswordWrapper>\n                );\n            }\n\n            return inputNode;\n        }\n    }\n}\n\nfunction InputTag(props: InputFieldByTypeProps & { fieldIndex: number | undefined }) {\n    const { attribute, fieldIndex, kcClsx, dispatchFormAction, valueOrValues, i18n, displayableErrors } = props;\n\n    const { advancedMsgStr } = i18n;\n\n    return (\n        <>\n            <Input\n                type={(() => {\n                    const { inputType } = attribute.annotations;\n\n                    if (inputType?.startsWith(\"html5-\")) {\n                        return inputType.slice(6);\n                    }\n\n                    return inputType ?? \"text\";\n                })()}\n                id={attribute.name}\n                name={attribute.name}\n                value={(() => {\n                    if (fieldIndex !== undefined) {\n                        assert(valueOrValues instanceof Array);\n                        return valueOrValues[fieldIndex];\n                    }\n\n                    assert(typeof valueOrValues === \"string\");\n\n                    return valueOrValues;\n                })()}\n                // className={kcClsx(\"kcInputClass\")}\n                aria-invalid={displayableErrors.find(error => error.fieldIndex === fieldIndex) !== undefined}\n                disabled={attribute.readOnly}\n                autoComplete={attribute.autocomplete}\n                placeholder={\n                    attribute.annotations.inputTypePlaceholder === undefined ? undefined : advancedMsgStr(attribute.annotations.inputTypePlaceholder)\n                }\n                pattern={attribute.annotations.inputTypePattern}\n                size={attribute.annotations.inputTypeSize === undefined ? undefined : parseInt(`${attribute.annotations.inputTypeSize}`)}\n                maxLength={\n                    attribute.annotations.inputTypeMaxlength === undefined ? undefined : parseInt(`${attribute.annotations.inputTypeMaxlength}`)\n                }\n                minLength={\n                    attribute.annotations.inputTypeMinlength === undefined ? undefined : parseInt(`${attribute.annotations.inputTypeMinlength}`)\n                }\n                max={attribute.annotations.inputTypeMax}\n                min={attribute.annotations.inputTypeMin}\n                step={attribute.annotations.inputTypeStep}\n                {...Object.fromEntries(Object.entries(attribute.html5DataAnnotations ?? {}).map(([key, value]) => [`data-${key}`, value]))}\n                onChange={event =>\n                    dispatchFormAction({\n                        action: \"update\",\n                        name: attribute.name,\n                        valueOrValues: (() => {\n                            if (fieldIndex !== undefined) {\n                                assert(valueOrValues instanceof Array);\n\n                                return valueOrValues.map((value, i) => {\n                                    if (i === fieldIndex) {\n                                        return event.target.value;\n                                    }\n\n                                    return value;\n                                });\n                            }\n\n                            return event.target.value;\n                        })()\n                    })\n                }\n                onBlur={() =>\n                    dispatchFormAction({\n                        action: \"focus lost\",\n                        name: attribute.name,\n                        fieldIndex: fieldIndex\n                    })\n                }\n            />\n            {(() => {\n                if (fieldIndex === undefined) {\n                    return null;\n                }\n\n                assert(valueOrValues instanceof Array);\n\n                const values = valueOrValues;\n\n                return (\n                    <>\n                        <FieldErrors attribute={attribute} kcClsx={kcClsx} displayableErrors={displayableErrors} fieldIndex={fieldIndex} />\n                        <AddRemoveButtonsMultiValuedAttribute\n                            attribute={attribute}\n                            values={values}\n                            fieldIndex={fieldIndex}\n                            dispatchFormAction={dispatchFormAction}\n                            i18n={i18n}\n                        />\n                    </>\n                );\n            })()}\n        </>\n    );\n}\n\nfunction AddRemoveButtonsMultiValuedAttribute(props: {\n    attribute: Attribute;\n    values: string[];\n    fieldIndex: number;\n    dispatchFormAction: React.Dispatch<Extract<FormAction, { action: \"update\" }>>;\n    i18n: I18n;\n}) {\n    const { attribute, values, fieldIndex, dispatchFormAction, i18n } = props;\n\n    const { msg } = i18n;\n\n    const { hasAdd, hasRemove } = getButtonToDisplayForMultivaluedAttributeField({ attribute, values, fieldIndex });\n\n    const idPostfix = `-${attribute.name}-${fieldIndex + 1}`;\n\n    return (\n        <>\n            {hasRemove && (\n                <>\n                    <button\n                        id={`kc-remove${idPostfix}`}\n                        type=\"button\"\n                        className=\"pf-c-button pf-m-inline pf-m-link\"\n                        onClick={() =>\n                            dispatchFormAction({\n                                action: \"update\",\n                                name: attribute.name,\n                                valueOrValues: values.filter((_, i) => i !== fieldIndex)\n                            })\n                        }\n                    >\n                        {msg(\"remove\")}\n                    </button>\n                    {hasAdd ? <>&nbsp;|&nbsp;</> : null}\n                </>\n            )}\n            {hasAdd && (\n                <button\n                    id={`kc-add${idPostfix}`}\n                    type=\"button\"\n                    className=\"pf-c-button pf-m-inline pf-m-link\"\n                    onClick={() =>\n                        dispatchFormAction({\n                            action: \"update\",\n                            name: attribute.name,\n                            valueOrValues: [...values, \"\"]\n                        })\n                    }\n                >\n                    {msg(\"addValue\")}\n                </button>\n            )}\n        </>\n    );\n}\n\nfunction InputTagSelects(props: InputFieldByTypeProps) {\n    const { attribute, dispatchFormAction, kcClsx, valueOrValues } = props;\n\n    const { advancedMsg } = props.i18n;\n\n    const { classDiv, classInput, classLabel, inputType } = (() => {\n        const { inputType } = attribute.annotations;\n\n        assert(inputType === \"select-radiobuttons\" || inputType === \"multiselect-checkboxes\");\n\n        switch (inputType) {\n            case \"select-radiobuttons\":\n                return {\n                    inputType: \"radio\",\n                    classDiv: kcClsx(\"kcInputClassRadio\"),\n                    classInput: kcClsx(\"kcInputClassRadioInput\"),\n                    classLabel: kcClsx(\"kcInputClassRadioLabel\")\n                };\n            case \"multiselect-checkboxes\":\n                return {\n                    inputType: \"checkbox\",\n                    classDiv: kcClsx(\"kcInputClassCheckbox\"),\n                    classInput: kcClsx(\"kcInputClassCheckboxInput\"),\n                    classLabel: kcClsx(\"kcInputClassCheckboxLabel\")\n                };\n        }\n    })();\n\n    const options = (() => {\n        walk: {\n            const { inputOptionsFromValidation } = attribute.annotations;\n\n            if (inputOptionsFromValidation === undefined) {\n                break walk;\n            }\n\n            const validator = (attribute.validators as Record<string, { options?: string[] }>)[inputOptionsFromValidation];\n\n            if (validator === undefined) {\n                break walk;\n            }\n\n            if (validator.options === undefined) {\n                break walk;\n            }\n\n            return validator.options;\n        }\n\n        return attribute.validators.options?.options ?? [];\n    })();\n\n    return (\n        <>\n            {options.map(option => (\n                <div key={option} className={classDiv}>\n                    <input\n                        type={inputType}\n                        id={`${attribute.name}-${option}`}\n                        name={attribute.name}\n                        value={option}\n                        className={classInput}\n                        aria-invalid={props.displayableErrors.length !== 0}\n                        disabled={attribute.readOnly}\n                        checked={valueOrValues instanceof Array ? valueOrValues.includes(option) : valueOrValues === option}\n                        onChange={event =>\n                            dispatchFormAction({\n                                action: \"update\",\n                                name: attribute.name,\n                                valueOrValues: (() => {\n                                    const isChecked = event.target.checked;\n\n                                    if (valueOrValues instanceof Array) {\n                                        const newValues = [...valueOrValues];\n\n                                        if (isChecked) {\n                                            newValues.push(option);\n                                        } else {\n                                            newValues.splice(newValues.indexOf(option), 1);\n                                        }\n\n                                        return newValues;\n                                    }\n\n                                    return event.target.checked ? option : \"\";\n                                })()\n                            })\n                        }\n                        onBlur={() =>\n                            dispatchFormAction({\n                                action: \"focus lost\",\n                                name: attribute.name,\n                                fieldIndex: undefined\n                            })\n                        }\n                    />\n                    <label\n                        htmlFor={`${attribute.name}-${option}`}\n                        className={`${classLabel}${attribute.readOnly ? ` ${kcClsx(\"kcInputClassRadioCheckboxLabelDisabled\")}` : \"\"}`}\n                    >\n                        {advancedMsg(option)}\n                    </label>\n                </div>\n            ))}\n        </>\n    );\n}\n\nfunction TextareaTag(props: InputFieldByTypeProps) {\n    const { attribute, dispatchFormAction, kcClsx, displayableErrors, valueOrValues } = props;\n\n    assert(typeof valueOrValues === \"string\");\n\n    const value = valueOrValues;\n\n    return (\n        <textarea\n            id={attribute.name}\n            name={attribute.name}\n            className={kcClsx(\"kcInputClass\")}\n            aria-invalid={displayableErrors.length !== 0}\n            disabled={attribute.readOnly}\n            cols={attribute.annotations.inputTypeCols === undefined ? undefined : parseInt(`${attribute.annotations.inputTypeCols}`)}\n            rows={attribute.annotations.inputTypeRows === undefined ? undefined : parseInt(`${attribute.annotations.inputTypeRows}`)}\n            maxLength={attribute.annotations.inputTypeMaxlength === undefined ? undefined : parseInt(`${attribute.annotations.inputTypeMaxlength}`)}\n            value={value}\n            onChange={event =>\n                dispatchFormAction({\n                    action: \"update\",\n                    name: attribute.name,\n                    valueOrValues: event.target.value\n                })\n            }\n            onBlur={() =>\n                dispatchFormAction({\n                    action: \"focus lost\",\n                    name: attribute.name,\n                    fieldIndex: undefined\n                })\n            }\n        />\n    );\n}\n\nfunction SelectTag(props: InputFieldByTypeProps) {\n    const { attribute, dispatchFormAction, kcClsx, displayableErrors, i18n, valueOrValues } = props;\n\n    const { advancedMsgStr } = i18n;\n\n    const isMultiple = attribute.annotations.inputType === \"multiselect\";\n\n    return (\n        <select\n            id={attribute.name}\n            name={attribute.name}\n            className={kcClsx(\"kcInputClass\")}\n            aria-invalid={displayableErrors.length !== 0}\n            disabled={attribute.readOnly}\n            multiple={isMultiple}\n            size={attribute.annotations.inputTypeSize === undefined ? undefined : parseInt(`${attribute.annotations.inputTypeSize}`)}\n            value={valueOrValues}\n            onChange={event =>\n                dispatchFormAction({\n                    action: \"update\",\n                    name: attribute.name,\n                    valueOrValues: (() => {\n                        if (isMultiple) {\n                            return Array.from(event.target.selectedOptions).map(option => option.value);\n                        }\n\n                        return event.target.value;\n                    })()\n                })\n            }\n            onBlur={() =>\n                dispatchFormAction({\n                    action: \"focus lost\",\n                    name: attribute.name,\n                    fieldIndex: undefined\n                })\n            }\n        >\n            {!isMultiple && <option value=\"\"></option>}\n            {(() => {\n                const options = (() => {\n                    walk: {\n                        const { inputOptionsFromValidation } = attribute.annotations;\n\n                        if (inputOptionsFromValidation === undefined) {\n                            break walk;\n                        }\n\n                        assert(typeof inputOptionsFromValidation === \"string\");\n\n                        const validator = (attribute.validators as Record<string, { options?: string[] }>)[inputOptionsFromValidation];\n\n                        if (validator === undefined) {\n                            break walk;\n                        }\n\n                        if (validator.options === undefined) {\n                            break walk;\n                        }\n\n                        return validator.options;\n                    }\n\n                    return attribute.validators.options?.options ?? [];\n                })();\n\n                return options.map(option => (\n                    <option key={option} value={option}>\n                        {(() => {\n                            if (attribute.annotations.inputOptionLabels !== undefined) {\n                                const { inputOptionLabels } = attribute.annotations;\n\n                                return advancedMsgStr(inputOptionLabels[option] ?? option);\n                            }\n\n                            if (attribute.annotations.inputOptionLabelsI18nPrefix !== undefined) {\n                                return advancedMsgStr(`${attribute.annotations.inputOptionLabelsI18nPrefix}.${option}`);\n                            }\n\n                            return option;\n                        })()}\n                    </option>\n                ));\n            })()}\n        </select>\n    );\n}\n","if (!Array.prototype.every) {\n    Array.prototype.every = function (callbackfn: any, thisArg: any) {\n        \"use strict\";\n        var T, k;\n\n        if (this == null) {\n            throw new TypeError(\"this is null or not defined\");\n        }\n\n        // 1. Let O be the result of calling ToObject passing the this\n        //    value as the argument.\n        var O = Object(this);\n\n        // 2. Let lenValue be the result of calling the Get internal method\n        //    of O with the argument \"length\".\n        // 3. Let len be ToUint32(lenValue).\n        var len = O.length >>> 0;\n\n        // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n        if (\n            typeof callbackfn !== \"function\" &&\n            Object.prototype.toString.call(callbackfn) !== \"[object Function]\"\n        ) {\n            throw new TypeError();\n        }\n\n        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n\n        // 6. Let k be 0.\n        k = 0;\n\n        // 7. Repeat, while k < len\n        while (k < len) {\n            var kValue;\n\n            // a. Let Pk be ToString(k).\n            //   This is implicit for LHS operands of the in operator\n            // b. Let kPresent be the result of calling the HasProperty internal\n            //    method of O with argument Pk.\n            //   This step can be combined with c\n            // c. If kPresent is true, then\n            if (k in O) {\n                var testResult;\n                // i. Let kValue be the result of calling the Get internal method\n                //    of O with argument Pk.\n                kValue = O[k];\n\n                // ii. Let testResult be the result of calling the Call internal method\n                // of callbackfn with T as the this value if T is not undefined\n                // else is the result of calling callbackfn\n                // and argument list containing kValue, k, and O.\n                if (T) testResult = callbackfn.call(T, kValue, k, O);\n                else testResult = callbackfn(kValue, k, O);\n\n                // iii. If ToBoolean(testResult) is false, return false.\n                if (!testResult) {\n                    return false;\n                }\n            }\n            k++;\n        }\n        return true;\n    };\n}\n"],"names":["structuredCloneButFunctions","o","Object","Array","map","fromEntries","entries","_ref","key","value","emailRegexp","formatNumber","input","format","digitPattern","match","maxSize","reduce","total","p","parseInt","replace","rawValue","length","substring","formatter","result","digits","RegExp","exec","i","useUserProfileForm","params","kcContext","i18n","doMakeUserConfirmPassword","insertScriptTags","useInsertScriptTags","componentOrHookName","scriptTags","keys","_b","_a","profile","html5DataAnnotations","filter","type","src","url","resourcesPath","useEffect","getErrors","messagesPerField","passwordPolicies","msg","msgStr","advancedMsg","advancedMsgStr","callback","callbackRef","useRef","current","useState","arguments","useConstCallback","attributeName","formFieldStates","formFieldState","find","_ref6","attribute","name","assert","undefined","valueOrValues","kcNumberUnFormat","server_side_error","multivalued","defaultValues","values","JSON","stringify","slice","defaultValue","doesErrorExist","existsError","_c","errorMessageStr","get","errorMessage","_jsx","dangerouslySetInnerHTML","__html","fieldIndex","source","handle_multi_valued_multi_fields","getIsMultivaluedSingleField","errors","_len2","_ref7","_key2","index","specificValueErrors","assign","annotations","inputType","error","rule","acc","required_field","required","every","msgArgs","push","Fragment","children","handle_multi_valued_single_field","validatorName","validator","validators","min","minStr","isNaN","max","maxStr","Infinity","check_password_policy_x","policyName","policy","minLength","minNumberOfDigits","split","char","minNumberOfLowerCaseChar","toLowerCase","toUpperCase","minNumberOfUpperCaseChar","minNumberOfSpecialChar","usernameFormFieldState","usernameValue","emailFormFieldState","emailValue","password_confirm_matches_password","passwordFormFieldState","validator_x","ignoreEmptyValue","pattern","errorMessageKey","test","id","lastError","intValue","options","indexOf","useGetErrors","initialState","useMemo","attributes","attributesByName","register","realm","registrationEmailAsUsername","displayName","formData","readOnly","autocomplete","user","editUsernameAllowed","email","forEach","patch_legacy_group","group","groupDisplayHeader","groupDisplayDescription","groupAnnotations","displayHeader","displayDescription","passwordRequired","splice","initialFormFieldState","handle_multi_valued_attribute","apply_validator_min_range","hasLostFocusAtLeastOnce","state","dispatchFormAction","useReducer","reducer","formAction","_ref2","action","kcNumberFormat","displayErrorsImmediately","_len","_ref3","_key","_ref4","formState","hasLostFocusAtLeastOnceOrArr","valueOrValuesWrap","__rest","displayableErrors","isFormSubmittable","_ref5","startsWith","UserProfileFormFields","props","kcClsx","onIsFormSubmittableValueChange","BeforeField","AfterField","groupNameRef","className","_attribute$displayNam","_jsxs","GroupLabel","style","display","htmlFor","inputHelperTextBefore","InputFieldByType","FieldErrors","inputHelperTextAfter","_attribute$group","_attribute$group$name","_attribute$group2","_attribute$group$disp","groupHeaderText","_attribute$group$disp2","groupDescriptionText","arr","TextareaTag","SelectTag","InputTagSelects","_Fragment","InputTag","inputNode","PasswordWrapper","passwordInputId","_attribute$html5DataA","Input","disabled","autoComplete","placeholder","inputTypePlaceholder","inputTypePattern","size","inputTypeSize","maxLength","inputTypeMaxlength","inputTypeMinlength","inputTypeMax","inputTypeMin","step","inputTypeStep","onChange","event","target","onBlur","AddRemoveButtonsMultiValuedAttribute","hasAdd","hasRemove","minCount","maxCount","getButtonToDisplayForMultivaluedAttributeField","idPostfix","onClick","_","classDiv","classInput","classLabel","_attribute$validators","_attribute$validators2","walk","inputOptionsFromValidation","option","checked","includes","isChecked","newValues","cols","inputTypeCols","rows","inputTypeRows","isMultiple","multiple","from","selectedOptions","_attribute$validators3","_attribute$validators4","inputOptionLabels","_inputOptionLabels$op","inputOptionLabelsI18nPrefix","prototype","callbackfn","thisArg","T","k","this","TypeError","O","len","toString","call","kValue"],"sourceRoot":""}